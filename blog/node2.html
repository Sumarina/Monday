<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>nodejs 从入门到放弃（二） | 今天星期一</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="不积跬步无以至千里">
    <link rel="preload" href="/assets/css/0.styles.48bb18a6.css" as="style"><link rel="preload" href="/assets/js/app.db82df2a.js" as="script"><link rel="preload" href="/assets/js/2.19d91b71.js" as="script"><link rel="preload" href="/assets/js/55.16978941.js" as="script"><link rel="prefetch" href="/assets/js/10.9c3425ea.js"><link rel="prefetch" href="/assets/js/11.3e199e06.js"><link rel="prefetch" href="/assets/js/12.29a33ffe.js"><link rel="prefetch" href="/assets/js/13.f2d1ab1c.js"><link rel="prefetch" href="/assets/js/14.18c00cc1.js"><link rel="prefetch" href="/assets/js/15.d1ff4747.js"><link rel="prefetch" href="/assets/js/16.eca88d43.js"><link rel="prefetch" href="/assets/js/17.ba139db4.js"><link rel="prefetch" href="/assets/js/18.c2daef91.js"><link rel="prefetch" href="/assets/js/19.785a5595.js"><link rel="prefetch" href="/assets/js/20.9663f362.js"><link rel="prefetch" href="/assets/js/21.8deeb702.js"><link rel="prefetch" href="/assets/js/22.60add185.js"><link rel="prefetch" href="/assets/js/23.aeff5dac.js"><link rel="prefetch" href="/assets/js/24.53921e05.js"><link rel="prefetch" href="/assets/js/25.109ae971.js"><link rel="prefetch" href="/assets/js/26.e75810d9.js"><link rel="prefetch" href="/assets/js/27.8edecbe4.js"><link rel="prefetch" href="/assets/js/28.eb59feb4.js"><link rel="prefetch" href="/assets/js/29.8cbbe449.js"><link rel="prefetch" href="/assets/js/3.27921659.js"><link rel="prefetch" href="/assets/js/30.762b8cf3.js"><link rel="prefetch" href="/assets/js/31.eadd436a.js"><link rel="prefetch" href="/assets/js/32.6224e51e.js"><link rel="prefetch" href="/assets/js/33.638f1cd3.js"><link rel="prefetch" href="/assets/js/34.05d8579d.js"><link rel="prefetch" href="/assets/js/35.010b89ea.js"><link rel="prefetch" href="/assets/js/36.2531d950.js"><link rel="prefetch" href="/assets/js/37.5150bebc.js"><link rel="prefetch" href="/assets/js/38.c0288100.js"><link rel="prefetch" href="/assets/js/39.03807c21.js"><link rel="prefetch" href="/assets/js/4.bef609f5.js"><link rel="prefetch" href="/assets/js/40.7b55f318.js"><link rel="prefetch" href="/assets/js/41.80e788c9.js"><link rel="prefetch" href="/assets/js/42.d76c3f40.js"><link rel="prefetch" href="/assets/js/43.9199ff1f.js"><link rel="prefetch" href="/assets/js/44.115dc96d.js"><link rel="prefetch" href="/assets/js/45.034cedda.js"><link rel="prefetch" href="/assets/js/46.f041d88e.js"><link rel="prefetch" href="/assets/js/47.8bb5cbf4.js"><link rel="prefetch" href="/assets/js/48.20e032d1.js"><link rel="prefetch" href="/assets/js/49.9e4a49e7.js"><link rel="prefetch" href="/assets/js/5.14eae1fe.js"><link rel="prefetch" href="/assets/js/50.90d8fef7.js"><link rel="prefetch" href="/assets/js/51.826d6679.js"><link rel="prefetch" href="/assets/js/52.468fea21.js"><link rel="prefetch" href="/assets/js/53.391121e2.js"><link rel="prefetch" href="/assets/js/54.2c8d4ec5.js"><link rel="prefetch" href="/assets/js/56.a7d1d627.js"><link rel="prefetch" href="/assets/js/57.2024241b.js"><link rel="prefetch" href="/assets/js/58.3a9dc90c.js"><link rel="prefetch" href="/assets/js/59.88252525.js"><link rel="prefetch" href="/assets/js/6.75805a0e.js"><link rel="prefetch" href="/assets/js/60.5a6902d2.js"><link rel="prefetch" href="/assets/js/61.31e9abe2.js"><link rel="prefetch" href="/assets/js/62.36060295.js"><link rel="prefetch" href="/assets/js/63.8a76c8a3.js"><link rel="prefetch" href="/assets/js/64.9e372e3b.js"><link rel="prefetch" href="/assets/js/65.f838d064.js"><link rel="prefetch" href="/assets/js/66.15c8b353.js"><link rel="prefetch" href="/assets/js/67.ce55f5bb.js"><link rel="prefetch" href="/assets/js/68.e4ccbdcb.js"><link rel="prefetch" href="/assets/js/69.f0ac3c9f.js"><link rel="prefetch" href="/assets/js/7.73c22fbe.js"><link rel="prefetch" href="/assets/js/70.41382755.js"><link rel="prefetch" href="/assets/js/71.87d5a175.js"><link rel="prefetch" href="/assets/js/72.4691e794.js"><link rel="prefetch" href="/assets/js/73.2d81ce1f.js"><link rel="prefetch" href="/assets/js/74.0d1d9728.js"><link rel="prefetch" href="/assets/js/8.9bf8a1a5.js"><link rel="prefetch" href="/assets/js/9.2e009041.js">
    <link rel="stylesheet" href="/assets/css/0.styles.48bb18a6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="今天星期一" class="logo"> <span class="site-name can-hide">今天星期一</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/JavaScript/0410.html" class="nav-link">
  JavaScript学习
</a></div><div class="nav-item"><a href="/css/0409.html" class="nav-link">
  css了解
</a></div><div class="nav-item"><a href="/algorithm/climbStairs.html" class="nav-link">
  算法练习
</a></div><div class="nav-item"><a href="/blog/0519.html" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/utils/0901.html" class="nav-link">
  手写utils
</a></div><div class="nav-item"><a href="https://github.com/Sumarina/Monday" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/JavaScript/0410.html" class="nav-link">
  JavaScript学习
</a></div><div class="nav-item"><a href="/css/0409.html" class="nav-link">
  css了解
</a></div><div class="nav-item"><a href="/algorithm/climbStairs.html" class="nav-link">
  算法练习
</a></div><div class="nav-item"><a href="/blog/0519.html" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/utils/0901.html" class="nav-link">
  手写utils
</a></div><div class="nav-item"><a href="https://github.com/Sumarina/Monday" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/0519.html" class="sidebar-link">网站性能优化</a></li><li><a href="/blog/0610.html" class="sidebar-link">设计一套账号体系 SDK 的流程</a></li><li><a href="/blog/node1.html" class="sidebar-link">nodejs 从入门到放弃（一）</a></li><li><a href="/blog/node2.html" aria-current="page" class="active sidebar-link">nodejs 从入门到放弃（二）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/node2.html#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/blog/node2.html#观察者" class="sidebar-link">观察者</a></li><li class="sidebar-sub-header"><a href="/blog/node2.html#请求对象" class="sidebar-link">请求对象</a></li><li class="sidebar-sub-header"><a href="/blog/node2.html#执行回调" class="sidebar-link">执行回调</a></li></ul></li><li><a href="/blog/node3.html" class="sidebar-link">nodejs 从入门到放弃（三）</a></li><li><a href="/blog/0916.html" class="sidebar-link">如何设计 UI 组件库</a></li><li><a href="/blog/vue解析.html" class="sidebar-link">vue 内部运行机制</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="nodejs-从入门到放弃（二）"><a href="#nodejs-从入门到放弃（二）" class="header-anchor">#</a> nodejs 从入门到放弃（二）</h1> <p>在 Node 中异步 I/O 是何等份量大伙多多少少应该知道点，没吃过猪肉难道还没见过猪跑么？
Node 虽然是单线程，但这里的单线程仅仅只是 Javascript 执行在单线程中罢了。
在 Node 中无论是何种平台，内部完成 I/O 任务的另有线程池。如下图所示：
<img src="/image/node/%E5%9F%BA%E4%BA%8Elibuv%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt="基于libuv的架构"></p> <hr> <p><em>那 Node 是如何实现异步 I/O 的呢？</em>
我们先看看其他内容，转移下注意力。</p> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <p>在进程启动时，Node 会创建一个类似<code>while(true)</code>的循环，每次循环的过程我们称之为 Tick。这个过程是为了检查是否有事件待处理，如果有则取出事件及相关的回调函数并执行，然后再进入下一个循环直到没有需要处理的事件则退出进程。如下图所示：
<img src="/image/node/Tick%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Tick流程图"></p> <h2 id="观察者"><a href="#观察者" class="header-anchor">#</a> 观察者</h2> <p>在每个 Tick 的过程中，如何判断是否有待处理的事件呢？那么就需要观察者登场啦。🎉🎉🎉
在每个事件循环中都会有一个或者多个观察者，判断是否待处理的事件就是向观察者询问是否有要处理的事件。就像咱们下馆子一样，馆子的厨房一遍一遍的做菜，厨房就是事件循环。那么他们做什么样的菜就需要询问服务员，服务员会告诉厨房有没有要做的菜，这里服务员便是观察者。具体做什么样的菜，就是咱们这些下馆子的人来决定的。</p> <h2 id="请求对象"><a href="#请求对象" class="header-anchor">#</a> 请求对象</h2> <p>一般，非异步回调函数是有我们自行调用。如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">processEvt</span><span class="token punctuation">(</span><span class="token parameter">list<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但对于 Node 的异步 I/O 调用而言，回调函数却不是我们开发者来调用，那么我们发出调用到回调函数被执行，这中间发生了什么呢？
事实上，从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中，存在一种中间产物，这就是<em>请求对象</em>。
下面以<code>fs.open()</code> 举例，探索 Node 与底层之间如如何执行异步 I/O 调用以及回调函数是如何被调用执行的。</p> <div class="language-js extra-class"><pre class="language-js"><code>fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'./files/test.txt'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fd</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//各种操作</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那<code>fs.open()</code>方法内部是什么样呢？</p> <div class="language-js extra-class"><pre class="language-js"><code>fs<span class="token punctuation">.</span><span class="token function-variable function">open</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//......</span>
  binding<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>pathModule<span class="token punctuation">.</span><span class="token function">_makeLong</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">stringToFlags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>从这两段代码中不难看出来 JavaScript 层面的代码通过 node 核心模块，核心模块调用 C++内建模块，内建模块又会做什么呢？看下图：
<img src="/image/node/%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="调用示意图">
内建模块会通过 libuv 进入系统调用，这也是 Node 里最经典的调用方式。
将 libuv 作为封装层，有两个平台的实现，实质上都是调用了<code>uv_fs_open()</code>方法，在<code>uv_fs_open()</code>的调用过程中，我们创建一个<em>FSReqWrap</em>请求对象，会把从 JavaScript 传入的参数和当前方法都封装在这个请求对象中，注意：回调函数会被设置在这个请求对象的 oncomplete_sym 属性上。
请求对象包装完毕后，在 windows 下，调用<code>QueueUserWorkItem()</code>方法将 FSReqWrap 这个请求对象推入到线程池中等待执行。
<code>QueueUserWorkItem()</code>方法接受三个参数，第一个参数是将要执行的方法的引用，第二个参数是方法运行时所需要的参数，第三个参数是执行的标识。
当线程池中有可用线程时，我们会调用传入的方法，根据参数调用底层相应的函数。
至此，JavaScript 调用就可以返回了，由 JavaScript 层面发起的异步调用第一阶段就结束了。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响 JavaScript 线程的后续执行，如此便达到了异步的目的。
<em>请求对象</em>是异步 I/O 过程中最重要的中间产物，因为所有状态都保存在这个对象中，包括送入线程池等待执行以及操作完毕后的回调处理。</p> <h2 id="执行回调"><a href="#执行回调" class="header-anchor">#</a> 执行回调</h2> <p>线程池中的 I/O 操作调用完毕后会将结果储存在某个属性上，通过调用<code>PostQueuedCompletionStatus()</code>通知 IOCP，告知当前对象操作已经完成，并将线程归还线程池。
我们通过<code>GetQueuedCompletionStatus()</code>提取。
在这个过程之，我们会调用事件循环的 I/O 观察者，在每次 Tick 的执行中，它会调用<code>GetQueuedCompletionStatus()</code>方法检查线程中是否有执行完的请求，如果存在，则会把请求对象加入的 I/O 观察队列中，将其当作事件处理。I/O 观察者回调函数的行为就是取出请求对象的结果属性作为参数，取出 oncomplete_sym 属性作为方法并执行。</p> <hr> <p>以上便是整个异步 I/O 的流程，看图：
<img src="/image/node/%E5%BC%82%E6%AD%A5IO%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="异步IO的流程">
那么读到这里，有没有醍醐灌顶？原来这就是 Node 中异步 I/O 的整个过程。
回到 Node 是如何实现异步 I/O 的问题，聪明如我的小伙伴们应该知道答案了吧。
事件循环、观察者、请求对象、I/O 线程池共同构成了 Node 异步的基本要素。</p> <hr> <p>ps:参考朴灵的《深入浅出》</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/node1.html" class="prev">
        nodejs 从入门到放弃（一）
      </a></span> <span class="next"><a href="/blog/node3.html">
        nodejs 从入门到放弃（三）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.db82df2a.js" defer></script><script src="/assets/js/2.19d91b71.js" defer></script><script src="/assets/js/55.16978941.js" defer></script>
  </body>
</html>
