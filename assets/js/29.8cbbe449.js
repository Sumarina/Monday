(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{384:function(e,n,t){"use strict";t.r(n);var v=t(43),_=Object(v.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"require-查找模块的顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#require-查找模块的顺序"}},[e._v("#")]),e._v(" require 查找模块的顺序")]),e._v(" "),t("p",[e._v("在 Node 中模块有两类：核心模块和文件模块。")]),e._v(" "),t("p",[e._v("在 Node 中引入模块需要三个步骤：")]),e._v(" "),t("ol",[t("li",[e._v("路径分析")]),e._v(" "),t("li",[e._v("文件定位")]),e._v(" "),t("li",[e._v("编译执行")])]),e._v(" "),t("p",[t("strong",[e._v("Node 也是采用缓存优先策略，对加载过的模块都会进行缓存，以减少二次引入的开销。当然，核心模块的加载是优于文件模块加载的。")])]),e._v(" "),t("p",[t("code",[e._v("require()")]),e._v("接受一个标识符作为参数,这个参数可以分为以下几类。")]),e._v(" "),t("ol",[t("li",[e._v("核心模块，如 http、fs、path 等。")]),e._v(" "),t("li",[e._v("相对路径或者绝对路径的文件模块。")]),e._v(" "),t("li",[e._v("非路径形式的文件模块，也就是自定义模块。")])]),e._v(" "),t("p",[e._v("核心模块是 Node 提供的模块，部分源码已经在编译过程编译成二进制文件，Node 启动时就部分核心模块会加载到内存中，所以就可以省略文件定位和编译执行的过程，并且在路径分析中又优先判断，所以加载速度是最快的。文件模块是用户编写的，在运行时动态加载，需要完整的经历那三个步骤，在运行速度上肯定是比不上核心模块的。")]),e._v(" "),t("p",[e._v("查找文件模块的时候，require()方法会把路径转化为真实路径，并作为索引查找，因为已经指定了具体路径，所以查找速度也是挺快的，速度仅次于核心模块。")]),e._v(" "),t("p",[e._v("最复查的是查找自定义模块。查找自定义模块会先分析扩展名，按照 js、json、node 的次序查找，查找过程会调用 fs 模块判断文件是否存在，因为 node 是单线程 ，所以这里在判断文件是否存在的时候容易发生阻塞。有个小的优化点是写清楚文件的扩展名，在 require()的标识符中带上完整的扩展名。分析完扩展名后如果找不到文件，但会获取到一个文件目录，node 会把这个目录当作一个包来处理，在当前目录下查找 package.json 文件，解析文件后取出 main 属性对应的文件名来定位，如果文件名没有扩展 ，则进入文件扩展分析阶段。如果文件名错误找不到或者 package.json 不存在，则会把 index 当作默认文件名，依次查找 index.js、index.json、index.node。如果在当前目录分析没找到对应文件，则会向上逐次递归，进入上一个模块目录查找，遍历完模块路径数组依旧找不到对应文件，则会抛出查找失败异常。")])])}),[],!1,null,null,null);n.default=_.exports}}]);