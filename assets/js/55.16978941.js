(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{408:function(t,a,s){"use strict";s.r(a);var n=s(43),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"nodejs-从入门到放弃（二）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-从入门到放弃（二）"}},[t._v("#")]),t._v(" nodejs 从入门到放弃（二）")]),t._v(" "),s("p",[t._v("在 Node 中异步 I/O 是何等份量大伙多多少少应该知道点，没吃过猪肉难道还没见过猪跑么？\nNode 虽然是单线程，但这里的单线程仅仅只是 Javascript 执行在单线程中罢了。\n在 Node 中无论是何种平台，内部完成 I/O 任务的另有线程池。如下图所示：\n"),s("img",{attrs:{src:"/image/node/%E5%9F%BA%E4%BA%8Elibuv%E7%9A%84%E6%9E%B6%E6%9E%84.png",alt:"基于libuv的架构"}})]),t._v(" "),s("hr"),t._v(" "),s("p",[s("em",[t._v("那 Node 是如何实现异步 I/O 的呢？")]),t._v("\n我们先看看其他内容，转移下注意力。")]),t._v(" "),s("h2",{attrs:{id:"事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),s("p",[t._v("在进程启动时，Node 会创建一个类似"),s("code",[t._v("while(true)")]),t._v("的循环，每次循环的过程我们称之为 Tick。这个过程是为了检查是否有事件待处理，如果有则取出事件及相关的回调函数并执行，然后再进入下一个循环直到没有需要处理的事件则退出进程。如下图所示：\n"),s("img",{attrs:{src:"/image/node/Tick%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"Tick流程图"}})]),t._v(" "),s("h2",{attrs:{id:"观察者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#观察者"}},[t._v("#")]),t._v(" 观察者")]),t._v(" "),s("p",[t._v("在每个 Tick 的过程中，如何判断是否有待处理的事件呢？那么就需要观察者登场啦。🎉🎉🎉\n在每个事件循环中都会有一个或者多个观察者，判断是否待处理的事件就是向观察者询问是否有要处理的事件。就像咱们下馆子一样，馆子的厨房一遍一遍的做菜，厨房就是事件循环。那么他们做什么样的菜就需要询问服务员，服务员会告诉厨房有没有要做的菜，这里服务员便是观察者。具体做什么样的菜，就是咱们这些下馆子的人来决定的。")]),t._v(" "),s("h2",{attrs:{id:"请求对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求对象"}},[t._v("#")]),t._v(" 请求对象")]),t._v(" "),s("p",[t._v("一般，非异步回调函数是有我们自行调用。如下所示：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("processEvt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("但对于 Node 的异步 I/O 调用而言，回调函数却不是我们开发者来调用，那么我们发出调用到回调函数被执行，这中间发生了什么呢？\n事实上，从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中，存在一种中间产物，这就是"),s("em",[t._v("请求对象")]),t._v("。\n下面以"),s("code",[t._v("fs.open()")]),t._v(" 举例，探索 Node 与底层之间如如何执行异步 I/O 调用以及回调函数是如何被调用执行的。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("fs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("open")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./files/test.txt'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//各种操作")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("那"),s("code",[t._v("fs.open()")]),t._v("方法内部是什么样呢？")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("fs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("open")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//......")]),t._v("\n  binding"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("open")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pathModule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_makeLong")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringToFlags")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("从这两段代码中不难看出来 JavaScript 层面的代码通过 node 核心模块，核心模块调用 C++内建模块，内建模块又会做什么呢？看下图：\n"),s("img",{attrs:{src:"/image/node/%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:"调用示意图"}}),t._v("\n内建模块会通过 libuv 进入系统调用，这也是 Node 里最经典的调用方式。\n将 libuv 作为封装层，有两个平台的实现，实质上都是调用了"),s("code",[t._v("uv_fs_open()")]),t._v("方法，在"),s("code",[t._v("uv_fs_open()")]),t._v("的调用过程中，我们创建一个"),s("em",[t._v("FSReqWrap")]),t._v("请求对象，会把从 JavaScript 传入的参数和当前方法都封装在这个请求对象中，注意：回调函数会被设置在这个请求对象的 oncomplete_sym 属性上。\n请求对象包装完毕后，在 windows 下，调用"),s("code",[t._v("QueueUserWorkItem()")]),t._v("方法将 FSReqWrap 这个请求对象推入到线程池中等待执行。\n"),s("code",[t._v("QueueUserWorkItem()")]),t._v("方法接受三个参数，第一个参数是将要执行的方法的引用，第二个参数是方法运行时所需要的参数，第三个参数是执行的标识。\n当线程池中有可用线程时，我们会调用传入的方法，根据参数调用底层相应的函数。\n至此，JavaScript 调用就可以返回了，由 JavaScript 层面发起的异步调用第一阶段就结束了。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响 JavaScript 线程的后续执行，如此便达到了异步的目的。\n"),s("em",[t._v("请求对象")]),t._v("是异步 I/O 过程中最重要的中间产物，因为所有状态都保存在这个对象中，包括送入线程池等待执行以及操作完毕后的回调处理。")]),t._v(" "),s("h2",{attrs:{id:"执行回调"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行回调"}},[t._v("#")]),t._v(" 执行回调")]),t._v(" "),s("p",[t._v("线程池中的 I/O 操作调用完毕后会将结果储存在某个属性上，通过调用"),s("code",[t._v("PostQueuedCompletionStatus()")]),t._v("通知 IOCP，告知当前对象操作已经完成，并将线程归还线程池。\n我们通过"),s("code",[t._v("GetQueuedCompletionStatus()")]),t._v("提取。\n在这个过程之，我们会调用事件循环的 I/O 观察者，在每次 Tick 的执行中，它会调用"),s("code",[t._v("GetQueuedCompletionStatus()")]),t._v("方法检查线程中是否有执行完的请求，如果存在，则会把请求对象加入的 I/O 观察队列中，将其当作事件处理。I/O 观察者回调函数的行为就是取出请求对象的结果属性作为参数，取出 oncomplete_sym 属性作为方法并执行。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("以上便是整个异步 I/O 的流程，看图：\n"),s("img",{attrs:{src:"/image/node/%E5%BC%82%E6%AD%A5IO%E7%9A%84%E6%B5%81%E7%A8%8B.png",alt:"异步IO的流程"}}),t._v("\n那么读到这里，有没有醍醐灌顶？原来这就是 Node 中异步 I/O 的整个过程。\n回到 Node 是如何实现异步 I/O 的问题，聪明如我的小伙伴们应该知道答案了吧。\n事件循环、观察者、请求对象、I/O 线程池共同构成了 Node 异步的基本要素。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("ps:参考朴灵的《深入浅出》")])])}),[],!1,null,null,null);a.default=e.exports}}]);